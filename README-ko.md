<p align="center">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="./assets/logo-dark.png">
    <source media="(prefers-color-scheme: light)" srcset="./assets/logo-light.png">
    <img alt="vericontext" src="./assets/logo-light.png" width="360">
  </picture>
</p>

<h3 align="center">문서는 거짓말한다. 해시는 안 한다.</h3>

<p align="center">
  코드를 참조하는 문서를 위한 SHA-256 인용 검증.<br>
  인용 하나 깨지면 문서 전체 실패. 의도된 설계.
</p>

<!-- BADGES:START -->
<!-- generated by add-badges 2026-02-23 -->
<p align="center">
  <a href="https://www.npmjs.com/package/vericontext"><img src="https://img.shields.io/npm/v/vericontext?style=flat-square&logo=npm&logoColor=white" alt="npm version"></a>
  <a href="LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue?style=flat-square" alt="License: MIT"></a>
  <a href="https://www.typescriptlang.org/"><img src="https://img.shields.io/badge/TypeScript-strict-3178C6?style=flat-square&logo=typescript&logoColor=white" alt="TypeScript"></a>
  <a href="https://modelcontextprotocol.io"><img src="https://img.shields.io/badge/MCP-compatible-8A2BE2?style=flat-square" alt="MCP compatible"></a>
  <a href="package.json"><img src="https://img.shields.io/badge/node-%3E%3D20-339933?style=flat-square&logo=nodedotjs&logoColor=white" alt="Node >= 20"></a>
</p>
<!-- BADGES:END -->

<p align="center">
  <a href="README.md">English</a> &middot;
  <b>한국어</b>
</p>

---

## 문제

AI 에이전트가 디렉토리마다 `README.md`, `AGENTS.md`를 뿌린다. 처음엔 좋다. 그런데 코드는 바뀌고 문서는 안 바뀐다. 파일이 이동됐는데 경로가 그대로, 함수가 바뀌었는데 설명이 그대로.

시간이 지나면 **문서가 거짓말을 한다.** 그 문서를 믿는 에이전트는 더 나쁜 결정을 내린다.

VeriContext는 문서가 코드를 인용할 때 **SHA-256 해시를 박아넣는다.** 나중에 검증하면 해시가 맞거나 틀리거나, 둘 중 하나. 퍼지 매칭 없음.

```
작성 시:  "핸들러 로직" [ [vctx:src/handler.ts#L30-L45@a1b2c3d4] ]
변경 후:  vericontext verify → ❌ hash_mismatch (a1b2c3d4 ≠ f5e6d7c8)
```

**인용 하나라도 깨지면 전체 실패.** Fail-closed.

## 어떻게 보이는지

인용은 HTML 주석 안에 들어간다 — GitHub, VSCode, 어떤 렌더러에서든 **완전히 안 보인다.**

**Raw Markdown:**

```markdown
인증 모듈이 로그인을 처리한다.
<!-- [ [vctx:src/auth.ts#L1-L50@abcd1234] ] -->

├── src/          <!-- [ [vctx-exists-dir:src/] ] -->
├── tests/        <!-- [ [vctx-exists-dir:tests/] ] -->
```

**렌더링:**

> 인증 모듈이 로그인을 처리한다.
>
> ├── src/
> ├── tests/

`vericontext verify`가 모든 인용을 찾아서 검증한다. `src/auth.ts`가 바뀌면 해시가 깨지고, 문서가 실패한다.

## 설치

```bash
npx skills add amsminn/vericontext --skill vericontext-enforcer
```

사용 중인 에이전트(Claude Code, Codex, Antigravity, Cursor, Windsurf, OpenCode 등)를 자동 감지하고 알맞은 경로에 설치한다. [40개 이상의 에이전트](https://github.com/vercel-labs/skills) 지원.

```bash
# 삭제
npx skills remove vericontext-enforcer
```

설치하면 에이전트가 자동으로:
- 문서에서 코드를 참조할 때 `[[vctx:...]]` 인용 삽입
- 커밋 전에 `vctx_verify_workspace` 실행
- 오래된 인용 발견 시 업데이트 요청

<details>
<summary>에이전트별 수동 설치</summary>

스킬은 `skills/vericontext-enforcer/SKILL.md`에 있다. 에이전트에 맞는 경로에 복사:

| 에이전트 | 스킬 경로 | MCP 별도 설정? |
|---------|-----------|---------------|
| **Claude Code** | `.claude/skills/vericontext-enforcer/` | 불필요 |
| **Antigravity** | `~/.gemini/antigravity/skills/vericontext-enforcer/` | 불필요 |
| **Codex** | `.codex/skills/vericontext-enforcer/` | 필요 |
| **Cursor** | `.cursor/rules/vericontext.mdc` | 필요 |
| **Windsurf** | `.windsurf/rules/vericontext.md` | 필요 |
| **OpenCode** | 프로젝트 rules | 필요 |

MCP가 필요한 에이전트는 설정에 서버 추가:

```json
{ "mcpServers": { "vericontext": { "command": "npx", "args": ["-y", "vericontext", "mcp"] } } }
```

MCP 도구: `vctx_cite`, `vctx_claim`, `vctx_verify_workspace`

</details>

## 작동 방식

세 가지 연산, 하나의 원칙: **해시하거나, 인정 안 됨.**

```
  cite           claim           verify
┌────────┐    ┌────────────┐    ┌───────────────────────┐
│  파일   │──→ │ [[vctx:..  │    │ 각 토큰마다:           │
│ +라인   │    │  @hash8]]  │    │   해시 재계산           │
└────────┘    └────────────┘    │   일치? → ok : fail    │
                                │ 하나라도 fail → 전체 fail│
                                └───────────────────────┘
```

1. **Cite** — 파일 라인 범위를 SHA-256 해시(앞 8자리)와 함께 스냅샷
2. **Claim** — 구조 사실 선언: `exists-dir`, `missing`
3. **Verify** — 모든 인용과 선언을 검증. 하나라도 틀리면 전체 실패

### 토큰 문법

| 유형 | 토큰 | 예시 |
|------|------|------|
| 코드 인용 | `[ [vctx:path#Lstart-Lend@hash8] ]` | `[ [vctx:src/cli.ts#L1-L10@a1b2c3d4] ]` |
| 디렉토리 존재 | `[ [vctx-exists-dir:path/] ]` | `[ [vctx-exists-dir:src/] ]` |
| 부재 | `[ [vctx-missing:path] ]` | `[ [vctx-missing:tmp-output/] ]` |

> **파일을 언급하면 반드시 해시한다.** 파일의 역할, 코드, 존재 여부 — 어떤 수준이든 `vctx_cite`로 전체 파일을 해시한다. 디렉토리만 `exists-dir` claim을 사용한다.

## CLI 레퍼런스

```bash
npm install -g vericontext    # 또는 npx 사용
```

### `cite` — 코드 인용 생성

```bash
npx vericontext cite --root <dir> --path <file> --start-line <n> --end-line <n> [--json]
```

### `claim` — 구조 선언 생성

```bash
npx vericontext claim --root <dir> --kind <kind> --path <path> [--json]
```

`--kind`: `exists` | `exists-file` | `exists-dir` | `missing`

### `verify workspace` — 문서 내 모든 인용 검증

```bash
npx vericontext verify workspace --root <dir> (--in-path <doc> | --text <text>) [--json]
```

| 종료 코드 | 의미 |
|----------|------|
| `0` | 모든 인용 유효 |
| `1` | 하나 이상 실패 |

<details>
<summary>에러 사유</summary>

| 사유 | 의미 |
|------|------|
| `hash_mismatch` | 인용된 내용이 변경됨 |
| `file_missing` | 파일이 존재하지 않음 |
| `path_escape` | root jail 밖으로 나가는 경로 |
| `range_invalid` | 라인 범위가 유효하지 않음 |
| `binary_file` | 바이너리 파일 감지 |
| `symlink_skipped` | 심볼릭 링크 스킵 (결정론적 동작) |
| `invalid_input` | 잘못된 입력 형식 |

</details>

### `mcp` — MCP 서버 실행

```bash
npx vericontext mcp
```

stdio로 `vctx_cite`, `vctx_claim`, `vctx_verify_workspace` 제공.

## GitHub Actions

```yaml
- name: Verify docs
  run: npx -y vericontext verify workspace --root . --in-path README.md --json
```

### Pre-commit Hook

```bash
# .husky/pre-commit
npx vericontext verify workspace --root . --in-path README.md --json
```

## 자체 검증 문서

이 README에는 숨겨진 VeriContext claim이 포함되어 있다. 검증:

```bash
npx vericontext verify workspace --root . --in-path README-ko.md --json
```

raw 소스에서 claim을 보려면 `cat README-ko.md` 또는 GitHub에서 "Raw" 클릭.

<!-- [[vctx-exists-dir:src/]] -->
<!-- [[vctx:src/cli.ts#L1-L111@d491e15a]] -->
<!-- [[vctx:src/mcp/server.ts#L1-L72@c68412d1]] -->
<!-- [[vctx-missing:tmp-output]] -->

## 기여

[CONTRIBUTING.md](CONTRIBUTING.md) 참고.

## 라이선스

[MIT](LICENSE)
